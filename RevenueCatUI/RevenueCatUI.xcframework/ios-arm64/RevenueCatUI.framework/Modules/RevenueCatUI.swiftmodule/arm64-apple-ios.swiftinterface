// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 effective-5.10 (swiftlang-6.2.1.4.8 clang-1700.4.4.1)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name RevenueCatUI
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.1
import AVKit
import Combine
import Foundation
import RegexBuilder
import RevenueCat
@_exported import RevenueCatUI
import SafariServices
import StoreKit
import Swift
import SwiftUI
import UIKit
import WebKit
import _AVKit_SwiftUI
import _Concurrency
import _StoreKit_SwiftUI
import _StringProcessing
import _SwiftConcurrencyShims
import _WebKit_SwiftUI
public struct CustomActionData {
  public let actionIdentifier: Swift.String
  public let purchaseIdentifier: Swift.String?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(actionIdentifier: Swift.String, purchaseIdentifier: Swift.String?)
  #endif
}
extension RevenueCatUI.CustomActionData : Swift.Equatable {
  public static func == (lhs: RevenueCatUI.CustomActionData, rhs: RevenueCatUI.CustomActionData) -> Swift.Bool
}
extension RevenueCatUI.CustomActionData : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCatUI.CustomActionData : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(*, deprecated, message: "Use the view modifiers in View+CustomerCenterActions.swift instead.\nFor example, use .onCustomerCenterRestoreStarted(), .onCustomerCenterRestoreCompleted(), etc.")
public typealias CustomerCenterActionHandler = @_Concurrency.MainActor @Sendable (RevenueCatUI.CustomerCenterAction) -> Swift.Void
public enum CustomerCenterAction {
  case restoreStarted
  case restoreFailed(_: any Swift.Error)
  case restoreCompleted(_: RevenueCat.CustomerInfo)
  case showingManageSubscriptions
  case refundRequestStarted(_: Swift.String)
  case refundRequestCompleted(_: RevenueCat.RefundRequestStatus)
  case feedbackSurveyCompleted(_: Swift.String)
}
public protocol CustomerCenterActionable {
}
public enum CustomerCenterManagementOption {
  public struct Cancel : RevenueCatUI.CustomerCenterActionable {
  }
  public struct CustomUrl : RevenueCatUI.CustomerCenterActionable {
    public let url: Foundation.URL
  }
  public struct MissingPurchase : RevenueCatUI.CustomerCenterActionable {
  }
  public struct RefundRequest : RevenueCatUI.CustomerCenterActionable {
  }
  public struct ChangePlans : RevenueCatUI.CustomerCenterActionable {
  }
  public struct CustomAction : RevenueCatUI.CustomerCenterActionable {
    public let actionIdentifier: Swift.String
    public let purchaseIdentifier: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(actionIdentifier: Swift.String, purchaseIdentifier: Swift.String?)
    #endif
  }
}
@available(iOS 15.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@_Concurrency.MainActor @preconcurrency public struct CustomerCenterNavigationLink<Label> : SwiftUICore.View where Label : SwiftUICore.View {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "Use the view modifiers instead.\nFor example, use .onCustomerCenterRestoreStarted(), .onCustomerCenterRestoreCompleted(), etc.")
  @_Concurrency.MainActor @preconcurrency public init(customerCenterActionHandler: RevenueCatUI.CustomerCenterActionHandler?, @SwiftUICore.ViewBuilder label: @escaping () -> Label)
  #endif
  @_Concurrency.MainActor @preconcurrency public init(@SwiftUICore.ViewBuilder label: @escaping () -> Label)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @available(iOS 15.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @available(macOS, unavailable)
  public typealias Body = @_opaqueReturnTypeOf("$s12RevenueCatUI28CustomerCenterNavigationLinkV4bodyQrvp", 0) __<Label>
}
public struct CustomerCenterNavigationOptions {
  public let usesNavigationStack: Swift.Bool
  public let usesExistingNavigation: Swift.Bool
  public let shouldShowCloseButton: Swift.Bool
  public let onCloseHandler: (() -> Swift.Void)?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(usesNavigationStack: Swift.Bool = true, usesExistingNavigation: Swift.Bool = false, shouldShowCloseButton: Swift.Bool = true, onCloseHandler: (() -> Swift.Void)? = nil)
  #endif
}
extension RevenueCatUI.CustomerCenterNavigationOptions {
  public static let `default`: RevenueCatUI.CustomerCenterNavigationOptions
}
@available(iOS 15.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@_Concurrency.MainActor @preconcurrency public struct CustomerCenterView : SwiftUICore.View {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "Use the view modifiers instead.\nFor example, use .onCustomerCenterRestoreStarted(),\n.onCustomerCenterRestoreCompleted(), etc.")
  @_Concurrency.MainActor @preconcurrency public init(customerCenterActionHandler: RevenueCatUI.CustomerCenterActionHandler?, navigationOptions: RevenueCatUI.CustomerCenterNavigationOptions = .default)
  #endif
  @_Concurrency.MainActor @preconcurrency public init(navigationOptions: RevenueCatUI.CustomerCenterNavigationOptions = .default)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @available(iOS 15.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @available(macOS, unavailable)
  public typealias Body = @_opaqueReturnTypeOf("$s12RevenueCatUI18CustomerCenterViewV4bodyQrvp", 0) __
}
@available(iOS 15.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension RevenueCatUI.CustomerCenterView {
  public typealias RestoreStartedHandler = @_Concurrency.MainActor @Sendable () -> Swift.Void
  public typealias RestoreFailedHandler = @_Concurrency.MainActor @Sendable (_ error: any Swift.Error) -> Swift.Void
  public typealias RestoreCompletedHandler = @_Concurrency.MainActor @Sendable (_ customerInfo: RevenueCat.CustomerInfo) -> Swift.Void
  public typealias ShowingManageSubscriptionsHandler = @_Concurrency.MainActor @Sendable () -> Swift.Void
  public typealias RefundRequestStartedHandler = @_Concurrency.MainActor @Sendable (_ productId: Swift.String) -> Swift.Void
  public typealias RefundRequestCompletedHandler = @_Concurrency.MainActor @Sendable (_ productId: Swift.String, _ status: RevenueCat.RefundRequestStatus) -> Swift.Void
  public typealias FeedbackSurveyCompletedHandler = @_Concurrency.MainActor @Sendable (_ optionId: Swift.String) -> Swift.Void
  public typealias ManagementOptionSelectedHandler = @_Concurrency.MainActor @Sendable (_ managementOption: any RevenueCatUI.CustomerCenterActionable) -> Swift.Void
  public typealias CustomActionHandler = @_Concurrency.MainActor @Sendable (_ actionIdentifier: Swift.String, _ purchaseIdentifier: Swift.String?) -> Swift.Void
  public typealias PromotionalOfferSuccessHandler = @_Concurrency.MainActor @Sendable () -> Swift.Void
  public typealias ChangePlansHandler = @_Concurrency.MainActor @Sendable (_ optionId: Swift.String) -> Swift.Void
}
@available(iOS 15.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func onCustomerCenterRestoreStarted(_ handler: @escaping RevenueCatUI.CustomerCenterView.RestoreStartedHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onCustomerCenterRestoreFailed(_ handler: @escaping RevenueCatUI.CustomerCenterView.RestoreFailedHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onCustomerCenterRestoreCompleted(_ handler: @escaping RevenueCatUI.CustomerCenterView.RestoreCompletedHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onCustomerCenterShowingManageSubscriptions(_ handler: @escaping RevenueCatUI.CustomerCenterView.ShowingManageSubscriptionsHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onCustomerCenterRefundRequestStarted(_ handler: @escaping RevenueCatUI.CustomerCenterView.RefundRequestStartedHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onCustomerCenterRefundRequestCompleted(_ handler: @escaping RevenueCatUI.CustomerCenterView.RefundRequestCompletedHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onCustomerCenterFeedbackSurveyCompleted(_ handler: @escaping RevenueCatUI.CustomerCenterView.FeedbackSurveyCompletedHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onCustomerCenterManagementOptionSelected(_ handler: @escaping RevenueCatUI.CustomerCenterView.ManagementOptionSelectedHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onCustomerCenterPromotionalOfferSuccess(_ handler: @escaping RevenueCatUI.CustomerCenterView.PromotionalOfferSuccessHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onCustomerCenterChangePlansSelected(_ handler: @escaping RevenueCatUI.CustomerCenterView.ChangePlansHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onCustomerCenterCustomActionSelected(_ handler: @escaping RevenueCatUI.CustomerCenterView.CustomActionHandler) -> some SwiftUICore.View
  
}
@_hasMissingDesignatedInitializers @available(iOS 15.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@_Concurrency.MainActor @preconcurrency public class CustomerCenterViewController : SwiftUI.UIHostingController<RevenueCatUI.CustomerCenterView> {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "Use the initializer with individual action handlers instead")
  @_Concurrency.MainActor @preconcurrency public init(customerCenterActionHandler: RevenueCatUI.CustomerCenterActionHandler?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(restoreStarted: RevenueCatUI.CustomerCenterView.RestoreStartedHandler? = nil, restoreCompleted: RevenueCatUI.CustomerCenterView.RestoreCompletedHandler? = nil, restoreFailed: RevenueCatUI.CustomerCenterView.RestoreFailedHandler? = nil, showingManageSubscriptions: RevenueCatUI.CustomerCenterView.ShowingManageSubscriptionsHandler? = nil, refundRequestStarted: RevenueCatUI.CustomerCenterView.RefundRequestStartedHandler? = nil, refundRequestCompleted: RevenueCatUI.CustomerCenterView.RefundRequestCompletedHandler? = nil, feedbackSurveyCompleted: RevenueCatUI.CustomerCenterView.FeedbackSurveyCompletedHandler? = nil, managementOptionSelected: RevenueCatUI.CustomerCenterView.ManagementOptionSelectedHandler? = nil, changePlansSelected: RevenueCatUI.CustomerCenterView.ChangePlansHandler? = nil, onCustomAction: RevenueCatUI.CustomerCenterView.CustomActionHandler? = nil, promotionalOfferSuccess: RevenueCatUI.CustomerCenterView.PromotionalOfferSuccessHandler? = nil)
  #endif
  @objc deinit
}
public protocol PaywallFontProvider {
  @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
  func font(for textStyle: SwiftUICore.Font.TextStyle) -> SwiftUICore.Font
}
open class DefaultPaywallFontProvider : RevenueCatUI.PaywallFontProvider {
  public init()
  @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
  open func font(for textStyle: SwiftUICore.Font.TextStyle) -> SwiftUICore.Font
  @objc deinit
}
open class CustomPaywallFontProvider : RevenueCatUI.PaywallFontProvider {
  public init(fontName: Swift.String)
  @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
  open func font(for textStyle: SwiftUICore.Font.TextStyle) -> SwiftUICore.Font
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 15.0, macOS 12.0, tvOS 15.0, *)
@objc(RCPaywallFooterViewController) @_Concurrency.MainActor @preconcurrency final public class PaywallFooterViewController : RevenueCatUI.PaywallViewController {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(offering: RevenueCat.Offering? = nil, performPurchase: @escaping RevenueCatUI.PerformPurchase, performRestore: @escaping RevenueCatUI.PerformRestore, dismissRequestedHandler: ((_ controller: RevenueCatUI.PaywallViewController) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @_Concurrency.MainActor @preconcurrency public init(offering: RevenueCat.Offering? = nil, dismissRequestedHandler: ((_ controller: RevenueCatUI.PaywallViewController) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "use init with Offering instead")
  @objc @_Concurrency.MainActor @preconcurrency public init(offeringIdentifier: Swift.String, dismissRequestedHandler: ((_ controller: RevenueCatUI.PaywallViewController) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "use init with Offering instead")
  @objc @_Concurrency.MainActor @preconcurrency public init(offeringIdentifier: Swift.String, fontName: Swift.String, dismissRequestedHandler: ((_ controller: RevenueCatUI.PaywallViewController) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  #endif
  @objc deinit
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@available(tvOS, unavailable, message: "RevenueCatUI does not support tvOS yet")
@_Concurrency.MainActor @preconcurrency public struct PaywallView : SwiftUICore.View {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(fonts: any RevenueCatUI.PaywallFontProvider = DefaultPaywallFontProvider(), displayCloseButton: Swift.Bool = false, performPurchase: RevenueCatUI.PerformPurchase? = nil, performRestore: RevenueCatUI.PerformRestore? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(offering: RevenueCat.Offering, fonts: any RevenueCatUI.PaywallFontProvider = DefaultPaywallFontProvider(), displayCloseButton: Swift.Bool = false, performPurchase: RevenueCatUI.PerformPurchase? = nil, performRestore: RevenueCatUI.PerformRestore? = nil)
  #endif
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @available(iOS 15.0, watchOS 8.0, macOS 12.0, *)
  @available(tvOS, unavailable, introduced: 15.0, message: "RevenueCatUI does not support tvOS yet")
  public typealias Body = @_opaqueReturnTypeOf("$s12RevenueCatUI11PaywallViewV4bodyQrvp", 0) __
}
@_hasMissingDesignatedInitializers @available(iOS 15.0, macOS 12.0, tvOS 15.0, *)
@objc(RCPaywallViewController) @_Concurrency.MainActor @preconcurrency public class PaywallViewController : UIKit.UIViewController {
  @objc @_Concurrency.MainActor @preconcurrency final weak public var delegate: (any RevenueCatUI.PaywallViewControllerDelegate)?
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @_Concurrency.MainActor @preconcurrency convenience public init(offering: RevenueCat.Offering? = nil, displayCloseButton: Swift.Bool = false, shouldBlockTouchEvents: Swift.Bool = false, dismissRequestedHandler: ((_ controller: RevenueCatUI.PaywallViewController) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency convenience public init(offering: RevenueCat.Offering? = nil, fonts: any RevenueCatUI.PaywallFontProvider, displayCloseButton: Swift.Bool = false, shouldBlockTouchEvents: Swift.Bool = false, performPurchase: RevenueCatUI.PerformPurchase? = nil, performRestore: RevenueCatUI.PerformRestore? = nil, dismissRequestedHandler: ((_ controller: RevenueCatUI.PaywallViewController) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "use init with Offering instead")
  @_Concurrency.MainActor @preconcurrency convenience public init(offeringIdentifier: Swift.String, fonts: any RevenueCatUI.PaywallFontProvider = DefaultPaywallFontProvider(), displayCloseButton: Swift.Bool = false, shouldBlockTouchEvents: Swift.Bool = false, dismissRequestedHandler: ((_ controller: RevenueCatUI.PaywallViewController) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  #endif
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidDisappear(_ animated: Swift.Bool)
  @objc(updateWithOffering:) @_Concurrency.MainActor @preconcurrency public func update(with offering: RevenueCat.Offering)
  @available(*, deprecated, message: "use init with Offering instead")
  @objc(updateWithOfferingIdentifier:) @_Concurrency.MainActor @preconcurrency public func update(with offeringIdentifier: Swift.String)
  @objc(updateWithDisplayCloseButton:) @_Concurrency.MainActor @preconcurrency public func update(with displayCloseButton: Swift.Bool)
  @objc(updateFontWithFontName:) @_Concurrency.MainActor @preconcurrency public func updateFont(with fontName: Swift.String)
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  #endif
  @objc deinit
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, *)
@objc(RCPaywallViewControllerDelegate) public protocol PaywallViewControllerDelegate {
  @objc(paywallViewControllerDidStartPurchase:) optional func paywallViewControllerDidStartPurchase(_ controller: RevenueCatUI.PaywallViewController)
  @objc(paywallViewController:didStartPurchaseWithPackage:) optional func paywallViewController(_ controller: RevenueCatUI.PaywallViewController, didStartPurchaseWith package: RevenueCat.Package)
  @objc(paywallViewController:didFinishPurchasingWithCustomerInfo:) optional func paywallViewController(_ controller: RevenueCatUI.PaywallViewController, didFinishPurchasingWith customerInfo: RevenueCat.CustomerInfo)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc(paywallViewController:didFinishPurchasingWithCustomerInfo:transaction:) optional func paywallViewController(_ controller: RevenueCatUI.PaywallViewController, didFinishPurchasingWith customerInfo: RevenueCat.CustomerInfo, transaction: RevenueCat.StoreTransaction?)
  #endif
  @objc(paywallViewControllerDidCancelPurchase:) optional func paywallViewControllerDidCancelPurchase(_ controller: RevenueCatUI.PaywallViewController)
  @objc(paywallViewController:didFailPurchasingWithError:) optional func paywallViewController(_ controller: RevenueCatUI.PaywallViewController, didFailPurchasingWith error: Foundation.NSError)
  @objc(paywallViewControllerDidStartRestore:) optional func paywallViewControllerDidStartRestore(_ controller: RevenueCatUI.PaywallViewController)
  @objc(paywallViewController:didFinishRestoringWithCustomerInfo:) optional func paywallViewController(_ controller: RevenueCatUI.PaywallViewController, didFinishRestoringWith customerInfo: RevenueCat.CustomerInfo)
  @objc(paywallViewController:didFailRestoringWithError:) optional func paywallViewController(_ controller: RevenueCatUI.PaywallViewController, didFailRestoringWith error: Foundation.NSError)
  @objc(paywallViewControllerWasDismissed:) optional func paywallViewControllerWasDismissed(_ controller: RevenueCatUI.PaywallViewController)
  @objc(paywallViewController:didChangeSizeTo:) optional func paywallViewController(_ controller: RevenueCatUI.PaywallViewController, didChangeSizeTo size: CoreFoundation.CGSize)
}
public struct ResumeAction : Swift.Sendable {
  public init(action: @escaping @Sendable (Swift.Bool) -> Swift.Void)
  @_Concurrency.MainActor public func resume(shouldProceed: Swift.Bool)
}
extension RevenueCatUI.ResumeAction {
  @_Concurrency.MainActor public func callAsFunction(shouldProceed: Swift.Bool = true)
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func onWebPurchaseRedemptionAttempt(perform completion: @escaping @Sendable (RevenueCat.WebPurchaseRedemptionResult) -> Swift.Void) -> some SwiftUICore.View
  
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@available(macOS, unavailable, message: "CustomerCenterView does not support macOS yet")
@available(tvOS, unavailable, message: "RevenueCatUI does not support tvOS yet")
@available(watchOS, unavailable, message: "CustomerCenterView does not support watchOS yet")
extension SwiftUICore.View {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "Use the version with individual action handlers instead")
  @_Concurrency.MainActor @preconcurrency public func presentCustomerCenter(isPresented: SwiftUICore.Binding<Swift.Bool>, customerCenterActionHandler: RevenueCatUI.CustomerCenterActionHandler?, presentationMode: RevenueCat.CustomerCenterPresentationMode = .default, onDismiss: (() -> Swift.Void)? = nil) -> some SwiftUICore.View
  
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public func presentCustomerCenter(isPresented: SwiftUICore.Binding<Swift.Bool>, presentationMode: RevenueCat.CustomerCenterPresentationMode = .default, restoreStarted: RevenueCatUI.CustomerCenterView.RestoreStartedHandler? = nil, restoreCompleted: RevenueCatUI.CustomerCenterView.RestoreCompletedHandler? = nil, restoreFailed: RevenueCatUI.CustomerCenterView.RestoreFailedHandler? = nil, showingManageSubscriptions: RevenueCatUI.CustomerCenterView.ShowingManageSubscriptionsHandler? = nil, refundRequestStarted: RevenueCatUI.CustomerCenterView.RefundRequestStartedHandler? = nil, refundRequestCompleted: RevenueCatUI.CustomerCenterView.RefundRequestCompletedHandler? = nil, feedbackSurveyCompleted: RevenueCatUI.CustomerCenterView.FeedbackSurveyCompletedHandler? = nil, managementOptionSelected: RevenueCatUI.CustomerCenterView.ManagementOptionSelectedHandler? = nil, onCustomAction: RevenueCatUI.CustomerCenterView.CustomActionHandler? = nil, changePlansSelected: RevenueCatUI.CustomerCenterView.ChangePlansHandler? = nil, onDismiss: (() -> Swift.Void)? = nil) -> some SwiftUICore.View
  
  #endif
}
public enum PaywallPresentationMode {
  case sheet
  @available(macOS, unavailable)
  case fullScreen
  public static func == (a: RevenueCatUI.PaywallPresentationMode, b: RevenueCatUI.PaywallPresentationMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCatUI.PaywallPresentationMode {
  public static let `default`: RevenueCatUI.PaywallPresentationMode
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct MyAppPurchaseLogic {
  public let performPurchase: RevenueCatUI.PerformPurchase
  public let performRestore: RevenueCatUI.PerformRestore
  public init(performPurchase: @escaping RevenueCatUI.PerformPurchase, performRestore: @escaping RevenueCatUI.PerformRestore)
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@available(tvOS, unavailable, message: "RevenueCatUI does not support tvOS yet")
extension SwiftUICore.View {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated: 1, renamed: "presentPaywallIfNeeded(requiredEntitlementIdentifier:offering:fonts:presentationMode:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:onDismiss:)")
  @available(tvOS, deprecated: 1, renamed: "presentPaywallIfNeeded(requiredEntitlementIdentifier:offering:fonts:presentationMode:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:onDismiss:)")
  @available(watchOS, deprecated: 1, renamed: "presentPaywallIfNeeded(requiredEntitlementIdentifier:offering:fonts:presentationMode:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:onDismiss:)")
  @available(macOS, deprecated: 1, renamed: "presentPaywallIfNeeded(requiredEntitlementIdentifier:offering:fonts:presentationMode:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:onDismiss:)")
  @available(macCatalyst, deprecated: 1, renamed: "presentPaywallIfNeeded(requiredEntitlementIdentifier:offering:fonts:presentationMode:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:onDismiss:)")
  @_Concurrency.MainActor @preconcurrency public func presentPaywallIfNeeded(requiredEntitlementIdentifier: Swift.String, offering: RevenueCat.Offering? = nil, fonts: any RevenueCatUI.PaywallFontProvider = DefaultPaywallFontProvider(), presentationMode: RevenueCatUI.PaywallPresentationMode = .default, purchaseStarted: @escaping RevenueCatUI.PurchaseStartedHandler, purchaseCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseCancelled: RevenueCatUI.PurchaseCancelledHandler? = nil, restoreCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseFailure: RevenueCatUI.PurchaseFailureHandler? = nil, restoreFailure: RevenueCatUI.PurchaseFailureHandler? = nil, onDismiss: (() -> Swift.Void)? = nil) -> some SwiftUICore.View
  
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public func presentPaywallIfNeeded(requiredEntitlementIdentifier: Swift.String, offering: RevenueCat.Offering? = nil, fonts: any RevenueCatUI.PaywallFontProvider = DefaultPaywallFontProvider(), presentationMode: RevenueCatUI.PaywallPresentationMode = .default, myAppPurchaseLogic: RevenueCatUI.MyAppPurchaseLogic? = nil, purchaseStarted: RevenueCatUI.PurchaseOfPackageStartedHandler? = nil, purchaseCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseCancelled: RevenueCatUI.PurchaseCancelledHandler? = nil, restoreStarted: RevenueCatUI.RestoreStartedHandler? = nil, restoreCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseFailure: RevenueCatUI.PurchaseFailureHandler? = nil, restoreFailure: RevenueCatUI.PurchaseFailureHandler? = nil, onDismiss: (() -> Swift.Void)? = nil) -> some SwiftUICore.View
  
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated: 1, renamed: "presentPaywallIfNeeded(offering:fonts:presentationMode:shouldDisplay:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:onDismiss:)")
  @available(tvOS, deprecated: 1, renamed: "presentPaywallIfNeeded(offering:fonts:presentationMode:shouldDisplay:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:onDismiss:)")
  @available(watchOS, deprecated: 1, renamed: "presentPaywallIfNeeded(offering:fonts:presentationMode:shouldDisplay:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:onDismiss:)")
  @available(macOS, deprecated: 1, renamed: "presentPaywallIfNeeded(offering:fonts:presentationMode:shouldDisplay:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:onDismiss:)")
  @available(macCatalyst, deprecated: 1, renamed: "presentPaywallIfNeeded(offering:fonts:presentationMode:shouldDisplay:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:onDismiss:)")
  @_Concurrency.MainActor @preconcurrency public func presentPaywallIfNeeded(offering: RevenueCat.Offering? = nil, fonts: any RevenueCatUI.PaywallFontProvider = DefaultPaywallFontProvider(), presentationMode: RevenueCatUI.PaywallPresentationMode = .default, myAppPurchaseLogic: RevenueCatUI.MyAppPurchaseLogic? = nil, shouldDisplay: @escaping @Sendable (RevenueCat.CustomerInfo) -> Swift.Bool, purchaseStarted: @escaping RevenueCatUI.PurchaseStartedHandler, purchaseCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseCancelled: RevenueCatUI.PurchaseCancelledHandler? = nil, restoreCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseFailure: RevenueCatUI.PurchaseFailureHandler? = nil, restoreFailure: RevenueCatUI.PurchaseFailureHandler? = nil, onDismiss: (() -> Swift.Void)? = nil) -> some SwiftUICore.View
  
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public func presentPaywallIfNeeded(offering: RevenueCat.Offering? = nil, fonts: any RevenueCatUI.PaywallFontProvider = DefaultPaywallFontProvider(), presentationMode: RevenueCatUI.PaywallPresentationMode = .default, myAppPurchaseLogic: RevenueCatUI.MyAppPurchaseLogic? = nil, shouldDisplay: @escaping @Sendable (RevenueCat.CustomerInfo) -> Swift.Bool, purchaseStarted: RevenueCatUI.PurchaseOfPackageStartedHandler? = nil, purchaseCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseCancelled: RevenueCatUI.PurchaseCancelledHandler? = nil, restoreStarted: RevenueCatUI.RestoreStartedHandler? = nil, restoreCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseFailure: RevenueCatUI.PurchaseFailureHandler? = nil, restoreFailure: RevenueCatUI.PurchaseFailureHandler? = nil, onDismiss: (() -> Swift.Void)? = nil) -> some SwiftUICore.View
  
  #endif
}
public typealias PaywallTierChangeHandler = @_Concurrency.MainActor @Sendable (_ tier: RevenueCat.PaywallData.Tier, _ localizedName: Swift.String) -> Swift.Void
@available(iOS 15.0, macOS 12.0, tvOS 15.0, *)
extension SwiftUICore.View {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated: 1, renamed: "paywallFooter(condensed:fonts:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:)")
  @available(tvOS, deprecated: 1, renamed: "paywallFooter(condensed:fonts:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:)")
  @available(watchOS, deprecated: 1, renamed: "paywallFooter(condensed:fonts:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:)")
  @available(macOS, unavailable, message: "Legacy paywalls are unavailable in macOS")
  @available(macCatalyst, deprecated: 1, renamed: "paywallFooter(condensed:fonts:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:)")
  @_Concurrency.MainActor @preconcurrency public func paywallFooter(condensed: Swift.Bool = false, fonts: any RevenueCatUI.PaywallFontProvider = DefaultPaywallFontProvider(), purchaseStarted: @escaping RevenueCatUI.PurchaseStartedHandler, purchaseCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseCancelled: RevenueCatUI.PurchaseCancelledHandler? = nil, restoreCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseFailure: RevenueCatUI.PurchaseFailureHandler? = nil, restoreFailure: RevenueCatUI.PurchaseFailureHandler? = nil) -> some SwiftUICore.View
  
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated: 1, renamed: "originalTemplatePaywallFooter(condensed:fonts:myAppPurchaseLogic:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:)")
  @available(tvOS, deprecated: 1, renamed: "originalTemplatePaywallFooter(condensed:fonts:myAppPurchaseLogic:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:)")
  @available(watchOS, deprecated: 1, renamed: "originalTemplatePaywallFooter(condensed:fonts:myAppPurchaseLogic:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:)")
  @available(macOS, unavailable, message: "Legacy paywalls are unavailable in macOS")
  @available(macCatalyst, deprecated: 1, renamed: "originalTemplatePaywallFooter(condensed:fonts:myAppPurchaseLogic:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:)")
  @_Concurrency.MainActor @preconcurrency public func paywallFooter(condensed: Swift.Bool = false, fonts: any RevenueCatUI.PaywallFontProvider = DefaultPaywallFontProvider(), myAppPurchaseLogic: RevenueCatUI.MyAppPurchaseLogic? = nil, purchaseStarted: RevenueCatUI.PurchaseOfPackageStartedHandler? = nil, purchaseCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseCancelled: RevenueCatUI.PurchaseCancelledHandler? = nil, restoreStarted: RevenueCatUI.RestoreStartedHandler? = nil, restoreCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseFailure: RevenueCatUI.PurchaseFailureHandler? = nil, restoreFailure: RevenueCatUI.PurchaseFailureHandler? = nil) -> some SwiftUICore.View
  
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS, unavailable, message: "Legacy paywalls are unavailable in macOS")
  @_Concurrency.MainActor @preconcurrency public func originalTemplatePaywallFooter(condensed: Swift.Bool = false, fonts: any RevenueCatUI.PaywallFontProvider = DefaultPaywallFontProvider(), myAppPurchaseLogic: RevenueCatUI.MyAppPurchaseLogic? = nil, purchaseStarted: RevenueCatUI.PurchaseOfPackageStartedHandler? = nil, purchaseCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseCancelled: RevenueCatUI.PurchaseCancelledHandler? = nil, restoreStarted: RevenueCatUI.RestoreStartedHandler? = nil, restoreCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseFailure: RevenueCatUI.PurchaseFailureHandler? = nil, restoreFailure: RevenueCatUI.PurchaseFailureHandler? = nil) -> some SwiftUICore.View
  
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated: 1, renamed: "paywallFooter(offering:condensed:fonts:myAppPurchaseLogic:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:)")
  @available(tvOS, deprecated: 1, renamed: "paywallFooter(offering:condensed:fonts:myAppPurchaseLogic:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:)")
  @available(watchOS, deprecated: 1, renamed: "paywallFooter(offering:condensed:fonts:myAppPurchaseLogic:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:)")
  @available(macOS, unavailable, message: "Legacy paywalls are unavailable in macOS")
  @available(macCatalyst, deprecated: 1, renamed: "paywallFooter(offering:condensed:fonts:myAppPurchaseLogic:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:)")
  @_disfavoredOverload @_Concurrency.MainActor @preconcurrency public func paywallFooter(offering: RevenueCat.Offering, condensed: Swift.Bool = false, fonts: any RevenueCatUI.PaywallFontProvider = DefaultPaywallFontProvider(), purchaseStarted: @escaping RevenueCatUI.PurchaseStartedHandler, purchaseCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseCancelled: RevenueCatUI.PurchaseCancelledHandler? = nil, restoreCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseFailure: RevenueCatUI.PurchaseFailureHandler? = nil, restoreFailure: RevenueCatUI.PurchaseFailureHandler? = nil) -> some SwiftUICore.View
  
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated: 1, renamed: "originalTemplatePaywallFooter(offering:condensed:fonts:myAppPurchaseLogic:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:)")
  @available(tvOS, deprecated: 1, renamed: "originalTemplatePaywallFooter(offering:condensed:fonts:myAppPurchaseLogic:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:)")
  @available(watchOS, deprecated: 1, renamed: "originalTemplatePaywallFooter(offering:condensed:fonts:myAppPurchaseLogic:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:)")
  @available(macOS, unavailable, message: "Legacy paywalls are unavailable in macOS")
  @available(macCatalyst, deprecated: 1, renamed: "originalTemplatePaywallFooter(offering:condensed:fonts:myAppPurchaseLogic:purchaseStarted:purchaseCompleted:purchaseCancelled:restoreStarted:restoreCompleted:purchaseFailure:restoreFailure:)")
  @_Concurrency.MainActor @preconcurrency public func paywallFooter(offering: RevenueCat.Offering, condensed: Swift.Bool = false, fonts: any RevenueCatUI.PaywallFontProvider = DefaultPaywallFontProvider(), myAppPurchaseLogic: RevenueCatUI.MyAppPurchaseLogic? = nil, purchaseStarted: RevenueCatUI.PurchaseOfPackageStartedHandler? = nil, purchaseCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseCancelled: RevenueCatUI.PurchaseCancelledHandler? = nil, restoreStarted: RevenueCatUI.RestoreStartedHandler? = nil, restoreCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseFailure: RevenueCatUI.PurchaseFailureHandler? = nil, restoreFailure: RevenueCatUI.PurchaseFailureHandler? = nil) -> some SwiftUICore.View
  
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS, unavailable, message: "Legacy paywalls are unavailable in macOS")
  @_Concurrency.MainActor @preconcurrency public func originalTemplatePaywallFooter(offering: RevenueCat.Offering, condensed: Swift.Bool = false, fonts: any RevenueCatUI.PaywallFontProvider = DefaultPaywallFontProvider(), myAppPurchaseLogic: RevenueCatUI.MyAppPurchaseLogic? = nil, purchaseStarted: RevenueCatUI.PurchaseOfPackageStartedHandler? = nil, purchaseCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseCancelled: RevenueCatUI.PurchaseCancelledHandler? = nil, restoreStarted: RevenueCatUI.RestoreStartedHandler? = nil, restoreCompleted: RevenueCatUI.PurchaseOrRestoreCompletedHandler? = nil, purchaseFailure: RevenueCatUI.PurchaseFailureHandler? = nil, restoreFailure: RevenueCatUI.PurchaseFailureHandler? = nil) -> some SwiftUICore.View
  
  #endif
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, *)
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func onPaywallTierChange(_ handler: @escaping RevenueCatUI.PaywallTierChangeHandler) -> some SwiftUICore.View
  
}
public typealias PurchaseOrRestoreCompletedHandler = @_Concurrency.MainActor @Sendable (RevenueCat.CustomerInfo) -> Swift.Void
public typealias PurchaseCompletedHandler = @_Concurrency.MainActor @Sendable (_ transaction: RevenueCat.StoreTransaction?, _ customerInfo: RevenueCat.CustomerInfo) -> Swift.Void
@available(iOS, deprecated: 1, renamed: "PurchaseOfPackageStartedHandler")
@available(tvOS, deprecated: 1, renamed: "PurchaseOfPackageStartedHandler")
@available(watchOS, deprecated: 1, renamed: "PurchaseOfPackageStartedHandler")
@available(macOS, deprecated: 1, renamed: "PurchaseOfPackageStartedHandler")
@available(macCatalyst, deprecated: 1, renamed: "PurchaseOfPackageStartedHandler")
public typealias PurchaseStartedHandler = @_Concurrency.MainActor @Sendable () -> Swift.Void
public typealias PurchaseOfPackageStartedHandler = @_Concurrency.MainActor @Sendable (_ package: RevenueCat.Package) -> Swift.Void
public typealias PurchaseCancelledHandler = @_Concurrency.MainActor @Sendable () -> Swift.Void
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public typealias PerformPurchase = @_Concurrency.MainActor @Sendable (_ packageToPurchase: RevenueCat.Package) async -> (userCancelled: Swift.Bool, error: (any Swift.Error)?)
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public typealias PerformRestore = @_Concurrency.MainActor @Sendable () async -> (success: Swift.Bool, error: (any Swift.Error)?)
public typealias PurchaseFailureHandler = @_Concurrency.MainActor @Sendable (Foundation.NSError) -> Swift.Void
public typealias RestoreStartedHandler = @_Concurrency.MainActor @Sendable () -> Swift.Void
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct PurchaseInitiatedAction : Swift.Sendable {
  public init(_ action: @escaping @Sendable (RevenueCat.Package, RevenueCatUI.ResumeAction) -> Swift.Void)
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct OfferCodeRedemptionInitiatedAction : Swift.Sendable {
  public init(_ action: @escaping @Sendable (RevenueCatUI.ResumeAction) -> Swift.Void)
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SwiftUICore.View {
  @available(iOS, deprecated: 1, renamed: "onPurchaseStarted(handler:)")
  @available(tvOS, deprecated: 1, renamed: "onPurchaseStarted(handler:)")
  @available(watchOS, deprecated: 1, renamed: "onPurchaseStarted(handler:)")
  @available(macOS, deprecated: 1, renamed: "onPurchaseStarted(handler:)")
  @available(macCatalyst, deprecated: 1, renamed: "onPurchaseStarted(handler:)")
  @_Concurrency.MainActor @preconcurrency public func onPurchaseStarted(_ handler: @escaping RevenueCatUI.PurchaseStartedHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onPurchaseStarted(_ handler: @escaping RevenueCatUI.PurchaseOfPackageStartedHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onPurchaseCompleted(_ handler: @escaping RevenueCatUI.PurchaseOrRestoreCompletedHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onPurchaseCompleted(_ handler: @escaping RevenueCatUI.PurchaseCompletedHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onPurchaseCancelled(_ handler: @escaping RevenueCatUI.PurchaseCancelledHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onRestoreStarted(_ handler: @escaping RevenueCatUI.RestoreStartedHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onRestoreCompleted(_ handler: @escaping RevenueCatUI.PurchaseOrRestoreCompletedHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onPurchaseFailure(_ handler: @escaping RevenueCatUI.PurchaseFailureHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onRestoreFailure(_ handler: @escaping RevenueCatUI.PurchaseFailureHandler) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onPurchaseInitiated(_ action: @escaping @Sendable (RevenueCat.Package, RevenueCatUI.ResumeAction) -> Swift.Void) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onOfferCodeRedemptionInitiated(_ action: @escaping @Sendable (RevenueCatUI.ResumeAction) -> Swift.Void) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func onRequestedDismissal(_ action: @escaping () -> Swift.Void) -> some SwiftUICore.View
  
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SwiftUICore.View {
  @inlinable @_Concurrency.MainActor @preconcurrency internal func onChangeOf<V>(_ value: V, perform action: @escaping (_ newValue: V) -> Swift.Void) -> some SwiftUICore.View where V : Swift.Equatable {
         
         
         
        if #available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *) {
            AnyView(self.onChange(of: value) { _, newValue in action(newValue) })
        } else {
            AnyView(self.onChange(of: value) { newValue in action(newValue) })
        }
    }
  
}
@available(iOS 15.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension RevenueCatUI.CustomerCenterNavigationLink : Swift.Sendable {}
@available(iOS 15.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension RevenueCatUI.CustomerCenterView : Swift.Sendable {}
@available(iOS 15.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension RevenueCatUI.CustomerCenterViewController : Swift.Sendable {}
@available(iOS 15.0, macOS 12.0, watchOS 8.0, *)
@available(tvOS, unavailable, message: "RevenueCatUI does not support tvOS yet")
extension RevenueCatUI.PaywallView : Swift.Sendable {}
extension RevenueCatUI.PaywallPresentationMode : Swift.Equatable {}
extension RevenueCatUI.PaywallPresentationMode : Swift.Hashable {}
